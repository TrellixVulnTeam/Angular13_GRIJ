import { Component, ElementRef, EventEmitter, Input, Output, } from "@angular/core";
import * as Chartist from "chartist";
import * as i0 from "@angular/core";
/**
 * Angular component which renders Chartist chart.
 *
 * See Chartist {@link https://gionkunz.github.io/chartist-js/api-documentation.html API documentation} and
 * {@link https://gionkunz.github.io/chartist-js/examples.html examples} for more information.
 * ### Example
 ```html
 <x-chartist
   [type]="type"
   [data]="data"
   [options]="options"
   [responsiveOptions]="responsiveOptions"
   [events]="events"
 ></x-chartist>
 ```
 */
export class ChartistComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Event emitted after Chartist chart has been initialized.
         *
         * Event handler function will receive chart instance argument.
         */
        this.initialized = new EventEmitter();
    }
    ngOnInit() {
        if (this.type && this.data) {
            this.renderChart();
        }
    }
    ngOnChanges(changes) {
        this.update(changes);
    }
    ngOnDestroy() {
        if (this.chart) {
            this.chart.detach();
            this.chart = null;
        }
    }
    renderChart() {
        const nativeElement = this.elementRef.nativeElement;
        if (!(this.type in Chartist)) {
            throw new Error(`${this.type} is not a valid chart type`);
        }
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const Chart = Chartist[this.type];
        this.chart = new Chart(nativeElement, this.data, this.options, this.responsiveOptions);
        if (this.events) {
            this.bindEvents();
        }
        this.initialized.emit(this.chart);
    }
    update(changes) {
        if (!this.type || !this.data) {
            return;
        }
        if (!this.chart || "type" in changes) {
            this.renderChart();
        }
        else if (changes.data || changes.options) {
            this.chart.update(this.data, this.options);
        }
    }
    bindEvents() {
        for (const event of Object.keys(this.events)) {
            this.chart.on(event, this.events[event]);
        }
    }
}
ChartistComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.6", ngImport: i0, type: ChartistComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
ChartistComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.2.6", type: ChartistComponent, selector: "x-chartist", inputs: { data: "data", type: "type", options: "options", responsiveOptions: "responsiveOptions", events: "events" }, outputs: { initialized: "initialized" }, usesOnChanges: true, ngImport: i0, template: "", isInline: true, styles: [":host{display:block}\n"] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.6", ngImport: i0, type: ChartistComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "x-chartist",
                    template: "",
                    styles: [
                        `
      :host {
        display: block;
      }
    `,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { data: [{
                type: Input
            }], type: [{
                type: Input
            }], options: [{
                type: Input
            }], responsiveOptions: [{
                type: Input
            }], events: [{
                type: Input
            }], initialized: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnRpc3QuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctY2hhcnRpc3Qvc3JjL2xpYi9jaGFydGlzdC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFJTCxNQUFNLEdBRVAsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxLQUFLLFFBQVEsTUFBTSxVQUFVLENBQUM7O0FBMEJyQzs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFZSCxNQUFNLE9BQU8saUJBQWlCO0lBNkM1QixZQUFvQixVQUFzQjtRQUF0QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBVjFDOzs7O1dBSUc7UUFFSCxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFtQixDQUFDO0lBSUwsQ0FBQztJQUU5QyxRQUFRO1FBQ04sSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDMUIsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3BCO0lBQ0gsQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2QsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNwQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztTQUNuQjtJQUNILENBQUM7SUFFRCxXQUFXO1FBQ1QsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7UUFFcEQsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxRQUFRLENBQUMsRUFBRTtZQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksNEJBQTRCLENBQUMsQ0FBQztTQUMzRDtRQUNELGdFQUFnRTtRQUNoRSxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWxDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQ3BCLGFBQWEsRUFDYixJQUFJLENBQUMsSUFBSSxFQUNULElBQUksQ0FBQyxPQUFPLEVBQ1osSUFBSSxDQUFDLGlCQUFpQixDQUN2QixDQUFDO1FBRUYsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1NBQ25CO1FBRUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxNQUFNLENBQUMsT0FBc0I7UUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQzVCLE9BQU87U0FDUjtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLE1BQU0sSUFBSSxPQUFPLEVBQUU7WUFDcEMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3BCO2FBQU0sSUFBSSxPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQUU7WUFDMUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDNUM7SUFDSCxDQUFDO0lBRUQsVUFBVTtRQUNSLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDNUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUMxQztJQUNILENBQUM7OzhHQXZHVSxpQkFBaUI7a0dBQWpCLGlCQUFpQixzT0FUbEIsRUFBRTsyRkFTRCxpQkFBaUI7a0JBWDdCLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLFlBQVk7b0JBQ3RCLFFBQVEsRUFBRSxFQUFFO29CQUNaLE1BQU0sRUFBRTt3QkFDTjs7OztLQUlDO3FCQUNGO2lCQUNGO2lHQU1DLElBQUk7c0JBREgsS0FBSztnQkFPTixJQUFJO3NCQURILEtBQUs7Z0JBT04sT0FBTztzQkFETixLQUFLO2dCQU9OLGlCQUFpQjtzQkFEaEIsS0FBSztnQkFXTixNQUFNO3NCQURMLEtBQUs7Z0JBU04sV0FBVztzQkFEVixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFNpbXBsZUNoYW5nZXMsXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgKiBhcyBDaGFydGlzdCBmcm9tIFwiY2hhcnRpc3RcIjtcblxuLyoqXG4gKiBQb3NzaWJsZSBjaGFydCB0eXBlc1xuICovXG5leHBvcnQgdHlwZSBDaGFydFR5cGUgPSBcIlBpZVwiIHwgXCJCYXJcIiB8IFwiTGluZVwiO1xuXG5leHBvcnQgdHlwZSBDaGFydEludGVyZmFjZXMgPVxuICB8IENoYXJ0aXN0LklDaGFydGlzdFBpZUNoYXJ0XG4gIHwgQ2hhcnRpc3QuSUNoYXJ0aXN0QmFyQ2hhcnRcbiAgfCBDaGFydGlzdC5JQ2hhcnRpc3RMaW5lQ2hhcnQ7XG5leHBvcnQgdHlwZSBDaGFydE9wdGlvbnMgPVxuICB8IENoYXJ0aXN0LklCYXJDaGFydE9wdGlvbnNcbiAgfCBDaGFydGlzdC5JTGluZUNoYXJ0T3B0aW9uc1xuICB8IENoYXJ0aXN0LklQaWVDaGFydE9wdGlvbnM7XG5leHBvcnQgdHlwZSBSZXNwb25zaXZlT3B0aW9uVHVwbGUgPVxuICBDaGFydGlzdC5JUmVzcG9uc2l2ZU9wdGlvblR1cGxlPENoYXJ0T3B0aW9ucz47XG5leHBvcnQgdHlwZSBSZXNwb25zaXZlT3B0aW9ucyA9IFJlc3BvbnNpdmVPcHRpb25UdXBsZVtdO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY2hhcnQgZXZlbnRzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXJ0RXZlbnQge1xuICBbZXZlbnROYW1lOiBzdHJpbmddOiAoZGF0YTogYW55KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIEFuZ3VsYXIgY29tcG9uZW50IHdoaWNoIHJlbmRlcnMgQ2hhcnRpc3QgY2hhcnQuXG4gKlxuICogU2VlIENoYXJ0aXN0IHtAbGluayBodHRwczovL2dpb25rdW56LmdpdGh1Yi5pby9jaGFydGlzdC1qcy9hcGktZG9jdW1lbnRhdGlvbi5odG1sIEFQSSBkb2N1bWVudGF0aW9ufSBhbmRcbiAqIHtAbGluayBodHRwczovL2dpb25rdW56LmdpdGh1Yi5pby9jaGFydGlzdC1qcy9leGFtcGxlcy5odG1sIGV4YW1wbGVzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqICMjIyBFeGFtcGxlXG4gYGBgaHRtbFxuIDx4LWNoYXJ0aXN0XG4gICBbdHlwZV09XCJ0eXBlXCJcbiAgIFtkYXRhXT1cImRhdGFcIlxuICAgW29wdGlvbnNdPVwib3B0aW9uc1wiXG4gICBbcmVzcG9uc2l2ZU9wdGlvbnNdPVwicmVzcG9uc2l2ZU9wdGlvbnNcIlxuICAgW2V2ZW50c109XCJldmVudHNcIlxuID48L3gtY2hhcnRpc3Q+XG4gYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogXCJ4LWNoYXJ0aXN0XCIsXG4gIHRlbXBsYXRlOiBcIlwiLFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgfVxuICAgIGAsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENoYXJ0aXN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBUaGUgZGF0YSBvYmplY3QgdGhhdCBuZWVkcyB0byBjb25zaXN0IG9mIGEgbGFiZWxzIGFuZCBhIHNlcmllcyBhcnJheS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGRhdGE6IENoYXJ0aXN0LklDaGFydGlzdERhdGE7XG5cbiAgLyoqXG4gICAqIENoYXJ0aXN0IGNoYXJ0IHR5cGUuXG4gICAqL1xuICBASW5wdXQoKVxuICB0eXBlOiBDaGFydFR5cGU7XG5cbiAgLyoqXG4gICAqIFRoZSBvcHRpb25zIG9iamVjdCB3aGljaCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICovXG4gIEBJbnB1dCgpXG4gIG9wdGlvbnM6IENoYXJ0aXN0LklDaGFydE9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHJlc3BvbnNpdmUgb3B0aW9uIGFycmF5cyB3aGljaCBhcmUgYSBtZWRpYSBxdWVyeSBhbmQgb3B0aW9ucyBvYmplY3QgcGFpcjogW1ttZWRpYVF1ZXJ5U3RyaW5nLCBvcHRpb25zT2JqZWN0XSxbbW9yZS4uLl1dXG4gICAqL1xuICBASW5wdXQoKVxuICByZXNwb25zaXZlT3B0aW9uczogUmVzcG9uc2l2ZU9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEV2ZW50cyBvYmplY3Qgd2hlcmUga2V5cyBhcmUgQ2hhcnRpc3QgZXZlbnQgbmFtZXMgYW5kIHZhbHVlcyBhcmUgZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMuXG4gICAqXG4gICAqIFN1cHBvcnRlZCBldmVudHMgYXJlOiBkcmF3LCBvcHRpb25zQ2hhbmdlZCwgZGF0YSwgYW5pbWF0aW9uQmVnaW4sIGFuaW1hdGlvbkVuZCwgY3JlYXRlZC5cbiAgICpcbiAgICogRXZlbnQgaGFuZGxlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgYSBkYXRhIGFyZ3VtZW50IHdoaWNoIGNvbnRhaW5zIGV2ZW50IGRhdGEuXG4gICAqL1xuICBASW5wdXQoKVxuICBldmVudHM6IENoYXJ0RXZlbnQ7XG5cbiAgLyoqXG4gICAqIEV2ZW50IGVtaXR0ZWQgYWZ0ZXIgQ2hhcnRpc3QgY2hhcnQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAqXG4gICAqIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gd2lsbCByZWNlaXZlIGNoYXJ0IGluc3RhbmNlIGFyZ3VtZW50LlxuICAgKi9cbiAgQE91dHB1dCgpXG4gIGluaXRpYWxpemVkID0gbmV3IEV2ZW50RW1pdHRlcjxDaGFydEludGVyZmFjZXM+KCk7XG5cbiAgY2hhcnQ6IENoYXJ0SW50ZXJmYWNlcztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHt9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudHlwZSAmJiB0aGlzLmRhdGEpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGUoY2hhbmdlcyk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jaGFydCkge1xuICAgICAgdGhpcy5jaGFydC5kZXRhY2goKTtcbiAgICAgIHRoaXMuY2hhcnQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlckNoYXJ0KCkge1xuICAgIGNvbnN0IG5hdGl2ZUVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblxuICAgIGlmICghKHRoaXMudHlwZSBpbiBDaGFydGlzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLnR5cGV9IGlzIG5vdCBhIHZhbGlkIGNoYXJ0IHR5cGVgKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIGNvbnN0IENoYXJ0ID0gQ2hhcnRpc3RbdGhpcy50eXBlXTtcblxuICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2hhcnQoXG4gICAgICBuYXRpdmVFbGVtZW50LFxuICAgICAgdGhpcy5kYXRhLFxuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgdGhpcy5yZXNwb25zaXZlT3B0aW9uc1xuICAgICk7XG5cbiAgICBpZiAodGhpcy5ldmVudHMpIHtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZWQuZW1pdCh0aGlzLmNoYXJ0KTtcbiAgfVxuXG4gIHVwZGF0ZShjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnR5cGUgfHwgIXRoaXMuZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jaGFydCB8fCBcInR5cGVcIiBpbiBjaGFuZ2VzKSB7XG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KCk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2VzLmRhdGEgfHwgY2hhbmdlcy5vcHRpb25zKSB7XG4gICAgICB0aGlzLmNoYXJ0LnVwZGF0ZSh0aGlzLmRhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgYmluZEV2ZW50cygpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKHRoaXMuZXZlbnRzKSkge1xuICAgICAgdGhpcy5jaGFydC5vbihldmVudCwgdGhpcy5ldmVudHNbZXZlbnRdKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==